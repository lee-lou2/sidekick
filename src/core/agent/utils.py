"""Shared utilities and types for agent execution."""

import json
import logging
from dataclasses import dataclass, field
from typing import Any

import httpx
import tenacity
from pydantic_ai.exceptions import ModelHTTPError, UserError
from pydantic_ai.messages import BinaryContent, ModelMessage

from src.core.context import get_generated_images, set_attached_images  # noqa: F401
from src.utils.image_handler import ImageData, extract_images_from_result  # noqa: F401

logger = logging.getLogger(__name__)


def _should_retry(exc: BaseException) -> bool:
    """Determine if exception should be retried.

    Retry on transient errors (rate limits, server errors, timeouts).
    No retry on user errors or client errors.
    """
    # Never retry user/validation errors
    if isinstance(exc, UserError):
        return False
    # Retry on pydantic-ai ModelHTTPError for transient server errors
    if isinstance(exc, ModelHTTPError):
        return exc.status_code in (429, 500, 502, 503, 504)
    # Retry on transient HTTP errors
    if isinstance(exc, httpx.HTTPStatusError):
        return exc.response.status_code in (429, 500, 502, 503, 504)
    # Retry on connection/timeout errors
    if isinstance(exc, httpx.ConnectError | httpx.TimeoutException):
        return True
    return False


_retry_decorator = tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(multiplier=1, min=1, max=30),
    retry=tenacity.retry_if_exception(_should_retry),
    reraise=True,
)


def _store_images_in_context(images: list[ImageData]) -> None:
    """Store extracted images in context for edit_image tool access.

    This allows the edit_image tool to access images generated by other tools
    (like generate_image) within the same request or subsequent calls.

    Args:
        images: List of ImageData objects extracted from tool results.
    """
    if not images:
        return

    # Convert ImageData to the format expected by image_context
    context_images = []
    for img in images:
        context_images.append(
            {
                "bytes": img.data,
                "base64": img.to_data_uri().split(",", 1)[1]
                if "," in img.to_data_uri()
                else "",
                "mime_type": img.mime_type,
                "name": img.filename
                or f"generated_{len(context_images)}.{img.extension}",
            }
        )

    # Set in context (replaces any previously attached images)
    set_attached_images(context_images)
    logger.debug(
        "Stored %d generated image(s) in context for edit_image access",
        len(context_images),
    )


def _normalize_tool_result(content: Any) -> dict:
    """Normalize Pydantic AI tool result content to MCP format.

    Pydantic AI's FunctionToolResultEvent.result.content can be:
    - A string (simple tool result)
    - A list of content items (MCP format)
    - A dict (already normalized)
    - A BinaryContent object (e.g., Playwright MCP screenshots)
    - An object with attributes (e.g., MCP result objects)

    This adapter converts all formats to the dict format expected by
    extract_images_from_result().

    Args:
        content: Raw content from FunctionToolResultEvent.result.content

    Returns:
        Dict in format: {"content": [...]} for image extraction
    """
    logger.debug(
        "Normalizing tool result - type: %s, content preview: %s",
        type(content).__name__,
        str(content)[:200] if content else "None",
    )

    # Handle BinaryContent objects (Playwright MCP screenshots)
    if isinstance(content, BinaryContent):
        media_type = str(content.media_type)
        if media_type.startswith("image/"):
            logger.info(
                "Found BinaryContent image: media_type=%s, size=%d bytes",
                media_type,
                len(content.data),
            )
            return {
                "content": [
                    {
                        "type": "binary",
                        "media_type": media_type,
                        "content": content.base64,
                    }
                ]
            }
        return {"content": []}

    if isinstance(content, dict):
        return content
    if isinstance(content, list):
        # Check if list contains BinaryContent objects
        normalized_items = []
        for item in content:
            if isinstance(item, BinaryContent):
                media_type = str(item.media_type)
                if media_type.startswith("image/"):
                    logger.info(
                        "Found BinaryContent in list: media_type=%s, size=%d bytes",
                        media_type,
                        len(item.data),
                    )
                    normalized_items.append(
                        {
                            "type": "binary",
                            "media_type": media_type,
                            "content": item.base64,
                        }
                    )
            else:
                normalized_items.append(item)
        return {"content": normalized_items}
    if isinstance(content, str):
        if content.startswith("[") or content.startswith("{"):
            try:
                parsed = json.loads(content)
                if isinstance(parsed, list):
                    return {"content": parsed}
                if isinstance(parsed, dict):
                    return parsed
            except json.JSONDecodeError:
                pass
        return {"content": [{"type": "text", "text": content}]}

    # Check for .content attribute (MCP result objects)
    if hasattr(content, "content"):
        inner_content = content.content
        logger.debug("Found content attribute - type: %s", type(inner_content).__name__)
        return _normalize_tool_result(inner_content)

    # Check if iterable of content items
    if hasattr(content, "__iter__") and not isinstance(content, str | bytes):
        try:
            items = list(content)
            if items:
                return _normalize_tool_result(items)
        except (TypeError, ValueError):
            pass

    logger.warning(
        "Unknown tool result type: %s, cannot extract images", type(content).__name__
    )
    return {"content": []}


@dataclass
class AgentRunResult:
    """Result from agent run with extracted images."""

    output: str  # Final text response
    images: list[ImageData]  # Images extracted from tool results
    messages: list[ModelMessage] = field(default_factory=list)  # For message history
